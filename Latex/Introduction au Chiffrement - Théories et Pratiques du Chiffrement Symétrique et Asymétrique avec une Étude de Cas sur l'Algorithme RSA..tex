%%
% Copyright (c) 2017 - 2021, Pascal Wagler;
% Copyright (c) 2014 - 2021, John MacFarlane
%
% All rights reserved.
%
% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions
% are met:
%
% - Redistributions of source code must retain the above copyright
% notice, this list of conditions and the following disclaimer.
%
% - Redistributions in binary form must reproduce the above copyright
% notice, this list of conditions and the following disclaimer in the
% documentation and/or other materials provided with the distribution.
%
% - Neither the name of John MacFarlane nor the names of other
% contributors may be used to endorse or promote products derived
% from this software without specific prior written permission.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
% "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
% LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
% FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
% COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
% INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
% BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
% LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
% CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
% LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
% ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%%

%%
% This is the Eisvogel pandoc LaTeX template.
%
% For usage information and examples visit the official GitHub page:
% https://github.com/Wandmalfarbe/pandoc-latex-template
%%

% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames,x11names,table}{xcolor}
%
\documentclass[
  paper=a4,
  ,captions=tableheading
]{scrartcl}
\usepackage{amsmath,amssymb}
% Use setspace anyway because we change the default line spacing.
% The spacing is changed early to affect the titlepage and the TOC.
\usepackage{setspace}
\setstretch{1.2}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math} % this also loads fontspec
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else
  % xetex/luatex font selection
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}

\usepackage{pgfpages} 
\usepackage[export]{adjustbox}
\usepackage{graphicx}
\usepackage{ragged2e}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\definecolor{default-linkcolor}{HTML}{A50000}
\definecolor{default-filecolor}{HTML}{A50000}
\definecolor{default-citecolor}{HTML}{4077C0}
\definecolor{default-urlcolor}{HTML}{4077C0}
\usepackage[margin=2.5cm,includehead=true,includefoot=true,centering,]{geometry}

% add backlinks to footnote references, cf. https://tex.stackexchange.com/questions/302266/make-footnote-clickable-both-ways
\usepackage{footnotebackref}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
\ifLuaTeX
\usepackage[bidi=basic]{babel}
\else
\usepackage[bidi=default]{babel}
\fi
\babelprovide[main,import]{french}
% get rid of language-specific shorthands (see #6817):
\let\LanguageShortHands\languageshorthands
\def\languageshorthands#1{}
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same}
\hypersetup{
  pdftitle={Introduction au Chiffrement : Théories et Pratiques du Chiffrement Symétrique et Asymétrique avec une Étude de Cas sur l'Algorithme RSA.},
  pdfauthor={Joshua Meffre},
  pdflang={fr},
  hidelinks,
  breaklinks=true,
  pdfcreator={LaTeX via pandoc with the Eisvogel template}}
\title{Introduction au Chiffrement : Théories et Pratiques du
Chiffrement Symétrique et Asymétrique avec une Étude de Cas sur
l'Algorithme RSA.}
\author{Joshua Meffre}
  \date{\today}




%%
%% added
%%


%
% for the background color of the title page
%
\usepackage{pagecolor}
\usepackage{afterpage}
\usepackage[margin=2.5cm,includehead=true,includefoot=true,centering]{geometry}

%
% break urls
%
\PassOptionsToPackage{hyphens}{url}

%
% When using babel or polyglossia with biblatex, loading csquotes is recommended
% to ensure that quoted texts are typeset according to the rules of your main language.
%
\usepackage{csquotes}

%
% captions
%
\definecolor{caption-color}{HTML}{777777}
\usepackage[font={stretch=1.2}, textfont={color=caption-color}, position=top, skip=4mm, labelfont=bf, singlelinecheck=false, justification=justified]{caption}
\setcapindent{0em}

%
% blockquote
%
\definecolor{blockquote-border}{RGB}{221,221,221}
\definecolor{blockquote-text}{RGB}{119,119,119}
\usepackage{mdframed}
\newmdenv[rightline=false,bottomline=false,topline=false,linewidth=3pt,linecolor=blockquote-border,skipabove=\parskip]{customblockquote}
\renewenvironment{quote}{\begin{customblockquote}\list{}{\rightmargin=0em\leftmargin=0em}%
\item\relax\color{blockquote-text}\ignorespaces}{\unskip\unskip\endlist\end{customblockquote}}

%
% Source Sans Pro as the de­fault font fam­ily
% Source Code Pro for monospace text
%
% 'default' option sets the default
% font family to Source Sans Pro, not \sfdefault.
%
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
    \usepackage[default]{sourcesanspro}
  \usepackage{sourcecodepro}
  \else % if not pdftex
    \usepackage[default]{sourcesanspro}
  \usepackage{sourcecodepro}

  % XeLaTeX specific adjustments for straight quotes: https://tex.stackexchange.com/a/354887
  % This issue is already fixed (see https://github.com/silkeh/latex-sourcecodepro/pull/5) but the
  % fix is still unreleased.
  % TODO: Remove this workaround when the new version of sourcecodepro is released on CTAN.
  \ifxetex
    \makeatletter
    \defaultfontfeatures[\ttfamily]
      { Numbers   = \sourcecodepro@figurestyle,
        Scale     = \SourceCodePro@scale,
        Extension = .otf }
    \setmonofont
      [ UprightFont    = *-\sourcecodepro@regstyle,
        ItalicFont     = *-\sourcecodepro@regstyle It,
        BoldFont       = *-\sourcecodepro@boldstyle,
        BoldItalicFont = *-\sourcecodepro@boldstyle It ]
      {SourceCodePro}
    \makeatother
  \fi
  \fi

%
% heading color
%
\definecolor{heading-color}{RGB}{40,40,40}
\addtokomafont{section}{\color{heading-color}}
% When using the classes report, scrreprt, book,
% scrbook or memoir, uncomment the following line.
%\addtokomafont{chapter}{\color{heading-color}}

%
% variables for title, author and date
%
\usepackage{titling}
\title{Introduction au Chiffrement : Théories et Pratiques du
Chiffrement Symétrique et Asymétrique avec une Étude de Cas sur
l'Algorithme RSA.}
\author{Joshua Meffre}
\date{}

%
% tables
%

%
% remove paragraph indention
%
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines

%
%
% Listings
%
%


%
% header and footer
%
\usepackage[headsepline,footsepline]{scrlayer-scrpage}

\newpairofpagestyles{eisvogel-header-footer}{
  \clearpairofpagestyles
  \ihead*{Introduction au Chiffrement : Théories et Pratiques du
Chiffrement Symétrique et Asymétrique avec une Étude de Cas sur
l'Algorithme RSA.}
  \chead*{}
  \ohead*{}
  \ifoot*{Joshua Meffre}
  \cfoot*{}
  \ofoot*{\thepage}
  \addtokomafont{pageheadfoot}{\upshape}
}
\pagestyle{eisvogel-header-footer}



%%
%% end added
%%
\usepackage{pgfpages}
\usepackage[export]{adjustbox}
\usepackage{graphicx}
\usepackage{ragged2e}


\begin{document}

%%
%% begin titlepage
%%
\begin{titlepage}
\newcommand{\colorRule}[3][black]{\textcolor[HTML]{#1}{\rule{#2}{#3}}}
\begin{flushleft}
\noindent
\\[-1em]
\color[HTML]{000000}
\makebox[0pt][l]{\colorRule[FFFFFF]{1.3\textwidth}{0pt}}
\par
\noindent

{
  \begin{center}
  \setstretch{1.4}
  \vfill
  \noindent {\huge \textbf{\textsf{
      Introduction au Chiffrement : Théories et Pratiques du Chiffrement
      Symétrique et Asymétrique avec une Étude de Cas sur l'Algorithme
      RSA.
  }}}
    \vskip 2em
  \noindent {\Large \textit{Joshua Meffre}}
  \vfill
  \end{center}
}

\end{flushleft}
\end{titlepage}
\restoregeometry
\pagenumbering{arabic} 

\AddToHook{cmd/section/before}{\clearpage}

%%
%% end titlepage
%%

% \maketitle
\pagenumbering{Roman} % set the numbering style to lowercase letter

\begin{center}
 {\LARGE \textbf{\textsf{Abstract}}}
\end{center}

\begin{abstract}
\begin{justify}
    Je tiens avant tout à apporter une précision : Je ne suis ni un
    scientifique ni un professionnel du domaine que j'avance ici. Cet
    article est le résultat d'énormément de curiosité et de passion de
    ma part et est né de ma volonté la plus humble de partager mes
    connaissances et mon enthousiasme pour ce sujet. Cet article est le
    fruit de mes recherches personnelles et de ma compréhension actuelle
    en la matière. Il est important de noter que malgré mes efforts pour
    fournir des informations précises et à jour, cet article peut
    contenir des erreurs ou des approximations. La complexité du
    chiffrement en fait une discipline en constante évolution, et ma
    compréhension reste limitée à ce que j'ai pu apprendre en amateur
    passionné. En conséquence, cet article ne doit EN AUCUN CAS être
    utilisé comme une source unique ou définitive pour un travail de
    recherche sérieux ou pour des utilisations professionnelles. Je vous
    encourage vivement à consulter des sources spécialisées et fiables
    dans le domaine, vous pourrez retrouver certaines de ces sources en
    fin d'article en plus des sources sur lesquelles je me suis moi-même
    appuyé pour l'écriture de ce dernier. Merci de lire cet article avec
    un esprit critique et une extrême vigilance. Mon objectif principal
    est de susciter l'intérêt et la curiosité pour un sujet que je
    trouve passionnant, et non de fournir une expertise technique
    exhaustive. CET ARTICLE N'EST PAS UN ARTICLE SCIENTIFIQUE ET IL NE
    CHERCHE PAS À L'ÊTRE.
  \end{justify}
\end{abstract}
\pagebreak



\pagenumbering{arabic} % set the numbering style to lowercase letter
\setcounter{page}{0} % Set the page counter to 3



\renewcommand*\contentsname{}
\renewcommand*\contentsname{Table of Contents}
{
\setcounter{tocdepth}{3}
\tableofcontents
\newpage
}
\section{1. Quelques notions avant de
commencer.}\label{quelques-notions-avant-de-commencer.}

Cet article contient des formules mathématiques et un jargon qui peuvent
paraître inhabituels pour les non-initiés, mais je tiens à vous
rassurer, \textbf{il n'y a rien de compliqué}. Cette première partie
existe justement pour vous aider à comprendre ou à vous remémorer les
terminologies mathématiques et le jargon verbal présent dans cet article
et nécessaire à sa bonne compréhension. N'hésitez pas à souvent y
revenir si vous vous sentez perdu. De plus, chaque fois qu'un terme
présent dans cette liste sera utilisé, il sera suivi d'un lien cliquable
vous permettant d'accéder facilement à la définition de celui-ci.

\subsection{1.1 Notions de
Mathématiques.}\label{notions-de-mathuxe9matiques.}

\paragraph{Def 1.1.1 :}\label{def-1.1.1}

Un \(\text{entier naturel}(\mathbb{N})\) est un nombre qui permet de
compter des unités équivalentes, on les reconnaît parce qu'il ne possède
pas de décimales, c'est-à-dire qu'ils ne possèdent pas de nombre après
la virgule \emph{(exemple : 30 est un entier naturel alors que 30,6
n'est pas un entier naturel)}.

\paragraph{Def 1.1.2 :}\label{def-1.1.2}

La \(\text{division euclidienne}(/)\) est une variante de la
\(\text{divison}(\div)\) et qui a pour particularité de ne travailler
qu'avec des \(\text{entiers naturels}(\mathbb{N})\), ce qui donne un
résultat en deux parties, le \(\text{quotient}(q)\) et le
\(\text{reste}(r)\).

\paragraph{Def 1.1.3 :}\label{def-1.1.3}

L'opérateur \(\text{modulo}\) (\(\;\bmod\;\)) est un opérateur qui
permet le calcul du reste d'une \(\text{division euclidienne}(/)\) et
qui renvoie le \(\text{reste}(r)\) comme résultat.

\paragraph{Def 1.1.4 :}\label{def-1.1.4}

L'opérateur de \(\text{congruence}(\equiv)\) est un opérateur de
vérification, comme l'opérateur d'\(\text{égalité}(=)\). Il vérifie
qu'une valeur \(a\) donne bien un résultat \(c\) lors d'une opération
\(a \bmod b\). Dans le cas où la vérification est fausse, alors \(a\)
n'est pas congruent(\(\not\equiv\)) à \(c \bmod b\)

\paragraph{Def 1.1.5 :}\label{def-1.1.5}

L'algèbre booléenne, est une algèbre dans lequelle on calcule des
valeurs ne pouvant posséder que deux états : \(faux\), \(vrai\)
\textbar{} \(0\), \(1\) \textbar{} \(éteint\), \(allumé\).

\paragraph{Def 1.1.6 :}\label{def-1.1.6}

Une table de vérité, en algèbre booléenne, est un tableau qui liste
toutes les combinaisons possibles des valeurs (\(0\) ou \(1\)) des
variables d'une expression booléenne et montre le résultat de
l'expression pour chacune de ces combinaisons.

\paragraph{Def 1.1.7 :}\label{def-1.1.7}

La porte logique \(XOR (\oplus)\) également appelé \emph{ou exclusif}
est un opérateur de l'algèbre booléenne dans lequel le résultat n'est
\(vrai\) que si les valeurs en entrée sont différentes. \emph{Table de
vérité :} \[
\begin{array}{|c|c|c|}
\hline
a & b & a \oplus b \\
\hline
0 & 0 & 0 \\
0 & 1 & 1 \\
1 & 0 & 1 \\
1 & 1 & 0 \\
\hline
\end{array}
\]

\subsection{1.2 Notions de Vocabulaire.}\label{notions-de-vocabulaire.}

\paragraph{Def 1.2.1 :}\label{def-1.2.1}

\textbf{En clair} \emph{(Ex : ``Message en clair'')} : En cryptographie,
le terme ``En clair'' fait référence à l'état d'un message ou d'une
information qui n'a pas été chiffrée d'une quelconque manière et qui est
compréhensible par tout le monde.

\paragraph{Def 1.2.2 :}\label{def-1.2.2}

\textbf{Clé de chiffrement} : La clé de chiffrement est la composante
qui permet la transformation d'un texte, d'une information ou d'une
valeur en clair en utilisant un algorithme de chiffrement.

\section{2. Contexte.}\label{contexte.}

\textbf{Cet article vise à partager une exploration du domaine de la
cryptographie, en partant d'une perspective personnelle. Il me semble
important de noter que mon intérêt pour ce sujet n'est pas le fruit d'un
attrait naturel, mais plutôt d'une série de circonstances fortuites qui
ont éveillé ma curiosité. Cette précision, bien que non essentielle à la
compréhension des concepts cryptographiques abordés ici, apporte un
éclairage contextuel que je pense pertinent. Le lecteur peut néanmoins
choisir de passer directement au chapitre suivant pour se concentrer sur
les aspects techniques de l'article.}

Étant de nature assez curieuse, et ayant eu très tôt accès à internet,
il ne m'est pas rare de m'éparpiller dans les recoins du web et de finir
par y trouver un sujet qui me prend de passion rapidement et devient mon
obsession pour une durée tout à fait aléatoire. C'est exactement ce qui
s'est passé récemment lorsque je suis pris de curiosité pour la pratique
du \emph{self-hosting}, dont j'utiliserai le terme français
``auto-hébergement''. Cette pratique, qu'on pourrait qualifier d'une
volonté d'indépendance numérique, consiste à héberger, chez soi, sur son
propre serveur informatique, les différents services que l'on retrouve
habituellement sur internet. Pourquoi le faire me direz-vous ? Comme
évoqué plus haut : l'indépendance, dans un monde de plus en plus régie
par les grandes entreprises du numérique, à une époque où celui-ci
devient quasiment indispensable, la volonté d'avoir le contrôle sur ce
que ces entreprises possèdent ou non devient de plus en plus un problème
que l'on cherche à résoudre\,; du moins, que \textbf{je} cherche à
résoudre. De plus, l'implémentation d'un serveur personnel chez soi
permet une acquisition de connaissances importantes dans le domaine de
l'informatique et dans la compréhension de celui-ci. Cependant, il ne
s'agit pas \emph{(encore)} d'un article sur l'auto-hébergement, je vais
donc aller au but. Après avoir fait l'acquisition d'une vieille tour
d'ordinateur qui me sert aujourd'hui de serveur personnel, il m'a fallu
le configurer, et parmi les étapes auquel il est complexe d'échapper, il
y a SSH (Secure Shell), un système bien pratique qui, pour simplifier
énormément, est un protocole de communication sécurisé, et qui, dans mon
exemple, me permet de communiquer avec mon serveur via d'autres
appareils partout dans le monde. La sécurité de cet outil repose sur un
principe fondamental : le chiffrement asymétrique ou le chiffrement à
clé publique. Ce type de chiffrement, qui est le responsable principal
de l'existence de cet article tant il a éveillé ma curiosité, possède
deux avantages majeurs, dont l'un d'eux me fait poser une question qui
viendra plus tard dans l'article, mais qui en est le cœur de mon
raisonnement. Cependant, avant de pouvoir l'aborder, j'ai besoin de
revenir un peu sur l'histoire du chiffrement et sur des notions
importantes qui l'entourent.

\section{3. La petite histoire du
chiffrement.}\label{la-petite-histoire-du-chiffrement.}

Les toutes premières traces de chiffrement remontent à 1900 av. J.-C.,
en Égypte antique lorsqu'un scribe esquisse les hiéroglyphes racontant
la vie de son seigneur. En effet, le système d'écriture des hiéroglyphes
qu'il utilise est assez inhabituel et volontairement complexe, bien
qu'il s'agit plutôt d'une volonté de rendre hommage de manière
harmonieuse à son seigneur afin de lui conférer dignité et autorité
plutôt qu'une intention explicite de chiffrement. Il est ainsi possible
de retrouver des phrases tel que ``In the year of Our Lord One thousand
eight hundred and sixty three'' (Dans l'année de notre seigneur
mille-huit-cent-soixante-trois), plutôt que d'avoir simplement écrit
``1863''. Bien qu'il ne s'agisse pas d'un type de chiffrement volontaire
et explicite, ce texte est responsable de la naissance de la
cryptographie puisque il incorpore un élément essentiel de celle-ci :
une transformation délibérée de l'écriture. \footnote{\href{https://archive.org/details/B-001-001-264/page/n47/mode/1up?view=theater}{Kahn,
  D. (1968). 2. The First 3,000 Years. In \emph{The Codebreakers: The
  story of secret writing} (pp.~71-78). essay, The Macmillan Company.}
  (En Anglais.)}

La première apparition s'apparentant à de la cryptographie moderne et
explicite date d'environ 1500 av. J.-C. et a été retrouvée en
Mésopotamie, ce qui s'apparente actuellement à l'Irak et la Syrie. Elle
y apparait sous forme d'une petite tablette contenant une ancienne
formule de fabrication de glaçures pour la poterie. Le scribe, qui,
visiblement, souhaitait garder sa formule bien secrètement, jouait sur
le fait que les signes cunéiformes (signes pouvant représenter
différentes syllabes ou sons) pouvaient posséder des valeurs syllabiques
différentes pour un même signe et choisissait volontairement les valeurs
les moins communes de chaque signe, rendant la lecture compliqué. Le
raisonnement de cette méthode ressemble à celle de George Bernard Shaw,
avec laquelle il est notamment possible d'écrire le mot anglais
\emph{fish} en \emph{ghoti} (le \emph{gh} faisant le son /f/ comme dans
le mot \emph{tou\textbf{gh}}, le \emph{o} faisant le son /i/ de
\emph{w\textbf{o}men} et \emph{ti} faisant le son /sh/ de
\emph{na\textbf{ti}on}). Ajoutez à cela que le scribe tronquait
également certains sons en ignorant volontairement la consonne finale
pour certains signes (par exemple si un signe représente la syllabe
\emph{kA}, le signe pouvait simplement être écrit \emph{k}.) et qu'un
même mot pouvait être composé de signes différents à chaque itération.
Ainsi est née la cryptographie. \footnote{\href{https://archive.org/details/B-001-001-264/page/n47/mode/1up?view=theater}{Kahn,
  D. (1968). 2. The First 3,000 Years. In \emph{The Codebreakers: The
  story of secret writing} (pp.~71-78). essay, The Macmillan Company.}
  (En Anglais.)}

\section{4. Le chiffre de César.}\label{le-chiffre-de-cuxe9sar.}

Mais l'exemple le plus connu, et qui sera ici le premier objet d'étude,
c'est le chiffre de César, \footnote{\href{https://sourcebooks.fordham.edu/ancient/suetonius-julius.asp}{Nom
  donné en rapport au fait que Jules César utilisait ce type de
  chiffrement pour ses communications secrètes.} (En Anglais.)} qui
porte officiellement le nom de chiffrement par décalage. Le concept,
s'il n'a pas déjà été saisi, est simple : décaler les lettres d'un
message en fonction de leurs positions dans l'alphabet et sur la base
d'une fonction mathématique. Ainsi pour un message \emph{``Bonjour''} et
pour une fonction \(+3\) on obtient \emph{``Erqmrxu''}. Si le concept
théorique reste simple à comprendre, il est intéressant de mettre en
place une description précise du procédé mathématique de cette méthode
de chiffrement. Ainsi cela va permettre au lecteur de s'habituer à la
lecture des raisonnement mathématiques qui seront présent tout au long
de cet article.

Pour chiffrer un message avec le chiffrement par décalage, on suit le
raisonnement suivant : \#\#\#\# Def 4.1.1 : Définir, pour chaque lettre,
un nombre en fonction de sa position dans l'alphabet, ainsi \(A = 0\) de
par sa première position dans l'alphabet, \(B = 1\), \(C = 2\), etc.

\paragraph{Def 4.1.2 :}\label{def-4.1.2}

Définir une valeur \(n\) nécessaire au décalage des lettres d'un message
(dans le chiffre de César \(n=3\)).

\paragraph{Def 4.1.3 :}\label{def-4.1.3}

Ainsi, il est possible d'encoder chaque lettre \(x\) d'un message via la
formule suivante : \[
E_n(x)=(x+n)\bmod26
\] Dans un objectif de clarification, il est permis de découper en deux
la présente opération :

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \((x+n)\) où \(x\) représente la valeur en clair
  \emph{\href{Introduction\%20au\%20Chiffrement\%20-\%20Théories\%20et\%20Pratiques\%20du\%20Chiffrement\%20Symétrique\%20et\%20Asymétrique\%20avec\%20une\%20Étude\%20de\%20Cas\%20sur\%20l'Algorithme\%20RSA.\#Def\%201.2.1}{(Def
  1.2.1)}} d'une lettre et où \(n\) représente la valeur de décalage. En
  additionnant ces deux valeurs ensembles, on obtient un nombre qui, une
  fois reconverti en lettre via la méthode utilisé en
  \emph{\href{Introduction\%20au\%20Chiffrement\%20-\%20Théories\%20et\%20Pratiques\%20du\%20Chiffrement\%20Symétrique\%20et\%20Asymétrique\%20avec\%20une\%20Étude\%20de\%20Cas\%20sur\%20l'Algorithme\%20RSA.\#Def\%204.1.1}{Def
  4.1.1}}, donne une lettre \(Z\) qui à pour objectif de servir de
  substitut de chiffrement à la lettre en clair initiale \emph{(exemple
  : si \(x = 2\) (donc la lettre \(D\)) et \(n=3\) le résultat de
  l'addition des deux valeurs \(x\) et \(n\) est de \(5\) (donc la
  lettre \(G\))}.
\item
  \(\bmod \;26\) est présent pour s'assurer que le résultat du décalage
  d'une lettre ne sorte pas des limites de l'alphabet \emph{(exemple :
  si \(x=25\) (donc la lettre \(Z\)) et \(n=3\), le résultat de \(x+n\)
  est de \(28\text{,}\) or \(28\) n'est égal à aucune lettre de
  l'alphabet, l'opérateur modulo
  \href{Introduction\%20au\%20Chiffrement\%20-\%20Théories\%20et\%20Pratiques\%20du\%20Chiffrement\%20Symétrique\%20et\%20Asymétrique\%20avec\%20une\%20Étude\%20de\%20Cas\%20sur\%20l'Algorithme\%20RSA.\#Def\%201.1.3}{(Def
  1.1.3)} est alors utilisée pour s'assurer de l'affirmation suivante :
  \(x+n < 26\). Si tel n'est pas le cas, alors l'opération
  \(\bmod \; 26\) permet de replacer la valeur de décalage au début de
  la liste (ici l'alphabet). Cela est dû au fait que dans l'opération
  \(Z \bmod 26\) (où \(Z=x+n\)) le résultat vaut toujours \(Z\) sauf si
  \(Z\geq26\), ce qui fait que, pour l'exemple cité plus haut où
  \(x=25\) et \(n=3\), le résultat de \(x+n \mod 26\) sera de \(2\)
  (donc la lettre \(D\)) et non \(28\) (qui ne correspond à aucune
  lettre de l'alphabet).)}
\end{enumerate}

\paragraph{Def 4.1.4 :}\label{def-4.1.4}

Pour déchiffrer le message il suffit de décoder chaque lettre en
utilisant la valeur inverse de \(n\) qui est égal à \(-n\), via la
formule suivante : \[
D_n(x)=(x-n) \bmod 26
\]

Il est important de noter que la valeur \(n\) constitue notre clé de
chiffrement et de déchiffrement. C'est cette clé qui permet d'appliquer
le décalage, et par conséquent le chiffrement notre message. Le fait que
la même clé est utilisée pour chiffrer et déchiffrer un message est
appelé chiffrement symétrique, car la même clé est utilisée dans les
deux sens.

\section{5. One Time Pad et chiffrement
symétrique.}\label{one-time-pad-et-chiffrement-symuxe9trique.}

Il existe plusieurs méthodes de chiffrement symétrique, chacune
présentant avantages et inconvénients, mais une analyse exhaustive de
chaque méthode serait longue et fastidieuse. Par conséquent, je me
concentrerai sur une méthode particulière : le One Time Pad (OTP), qui
se distingue des autres par une promesse unique : \textbf{être
incassable}. Cette affirmation est particulièrement remarquable dans le
domaine de la cryptographie, où l'on tend à éviter tout sentiment de
sécurité absolue et à considérer tout système comme théoriquement
vulnérable. Cependant, la promesse peut bel et bien être tenue si des
conditions bien précises sont réunies :

\paragraph{Def 5.1.1 :}\label{def-5.1.1}

La clé de chiffrement doit être générée de manière véritablement
aléatoire, sans motifs prédictibles.

\paragraph{Def 5.1.2 :}\label{def-5.1.2}

La longueur de la clé doit être égale à celle du message à chiffrer.

\paragraph{Def 5.1.3 :}\label{def-5.1.3}

Chaque clé générée ne doit être utilisée qu'une seule fois, afin
d'éviter les attaques par analyse statistique.

Ainsi, une fois toutes ces conditions réunies, tout message peut être
chiffré à l'aide du One Time Pad, garantissant ainsi l'inviolabilité de
l'information ou du message chiffré. Le OTP repose sur le fonctionnement
de la porte logique \(XOR (\oplus)\)
\emph{\href{Introduction\%20au\%20Chiffrement\%20-\%20Théories\%20et\%20Pratiques\%20du\%20Chiffrement\%20Symétrique\%20et\%20Asymétrique\%20avec\%20une\%20Étude\%20de\%20Cas\%20sur\%20l'Algorithme\%20RSA.\#Def\%201.1.6}{(Def
1.1.6)}} pour transformer une séquence de bits en une autre. L'avantage
de \(XOR (\oplus)\) réside dans le fait que pour un bit chiffré égal à
\(1\), la probabilité que le bit en clair soit \(0\) ou \(1\) est
équivalente (voir table de vérité en
\emph{\href{Introduction\%20au\%20Chiffrement\%20-\%20Théories\%20et\%20Pratiques\%20du\%20Chiffrement\%20Symétrique\%20et\%20Asymétrique\%20avec\%20une\%20Étude\%20de\%20Cas\%20sur\%20l'Algorithme\%20RSA.\#Def\%201.1.6}{Def
1.1.6}}). Illustrons cela avec un exemple pour clarifier les choses :
soit un message en clair représenté par la séquence de bits \(0110100\)
et une clé \(1100101\), il est possible de chiffrer le message en
commençant par le premier bit, on utilise donc l'opération
\(XOR (\oplus)\) comme suit : \[
0 \oplus 1 = 1
\] Pour chiffrer le deuxième bit, même opération : \[
1 \oplus 1 = 0
\] Puis récidiver la transformation pour chaque bit jusqu'à obtention du
message chiffré \(1010001\). Ainsi, un adversaire n'ayant accès qu'à ce
message chiffré ne pourrait en déduire le message en clair, car chaque
bit a une probabilité équivalente d'être \(1\) ou \(0\). En d'autres
termes, en l'absence de la clé de chiffrement, ce message chiffré
pourrait très bien correspondre à un message en clair initial
\(1111111\) ou tout aussi bien \(0000000\). 
\clearpage
Plus concrètement, il existe
un nombre de figures exponentiellement grand qui est uniquement limité
par la longueur du message. En termes mathématiques, pour un message de
longueur \(n\), il y a \(2^n\) configurations possibles.

Si le OPT possède une robustesse qui, en plus d'être impressionnante,
n'est pas à écarter, il possède pourtant une faiblesse qu'il partage
avec tous ses collègues du chiffrement symétrique : la transmission de
la clé. En effet, dans le cas où un message chiffré par une méthode de
chiffrement symétrique est envoyé, il faut pouvoir transmettre la clé au
récepteur du message afin que ce dernier puisse le déchiffrer. Et il
faut le faire sur un canal de communication suffisamment sécurisé pour
qu'elle ne soit pas interceptée, auquel cas l'action de chiffrer le
message perd son sens. Se présente donc le problème suivant :

\paragraph{Def 5.2.1 :}\label{def-5.2.1}

\emph{Si l'on peut transmettre la clé via un canal suffisamment sécurisé
pour qu'elle ne soit pas interceptée, pourquoi ne pas directement
envoyer le message en clair
\href{Introduction\%20au\%20Chiffrement\%20-\%20Théories\%20et\%20Pratiques\%20du\%20Chiffrement\%20Symétrique\%20et\%20Asymétrique\%20avec\%20une\%20Étude\%20de\%20Cas\%20sur\%20l'Algorithme\%20RSA.\#Def\%201.2.1}{(Def
1.2.1)} via ce même canal sécurisé ?}

En effet, il existe bien des solutions à ce problème, un exemple
classique consiste à définir un canal sécurisé de manière unique pour la
transmission de la clé, comme une rencontre en personne. Seulement cet
exemple reste peu pratique selon les situations et notamment dans le cas
du OTP, puisque selon la
\emph{\href{Introduction\%20au\%20Chiffrement\%20-\%20Théories\%20et\%20Pratiques\%20du\%20Chiffrement\%20Symétrique\%20et\%20Asymétrique\%20avec\%20une\%20Étude\%20de\%20Cas\%20sur\%20l'Algorithme\%20RSA.\#Def\%205.1.3}{Def
5.1.3}}, chaque clé doit être générée de manière unique, ce qui
nécessiterait donc une rencontre physique à chaque message, on en
revient donc à notre problème
\emph{\href{Introduction\%20au\%20Chiffrement\%20-\%20Théories\%20et\%20Pratiques\%20du\%20Chiffrement\%20Symétrique\%20et\%20Asymétrique\%20avec\%20une\%20Étude\%20de\%20Cas\%20sur\%20l'Algorithme\%20RSA.\#Def\%205.2.1}{Def
5.2.1}}. De plus, une telle rencontre présente rapidement des
limitations pratiques. Elle peut nécessiter des moyens considérables
selon la sensibilité des informations à échanger et qui se révèle même
impraticable dans les contextes de communications longue distance.

\section{6. Chiffrement asymétrique et Algorithme
RSA.}\label{chiffrement-asymuxe9trique-et-algorithme-rsa.}

Ainsi est introduit en 1976, par Whitfield Dillie et Martin E. Hellman,
le concept de cryptographie à clé publique. Ce concept repose sur la
génération d'une paire de clés de chiffrement, à l'instar du chiffrement
symétrique qui utilise une clé unique. La paire de clés se compose
respectivement d'une clé privée \(D\) de déchiffrement, qui doit rester
secrète, et d'une clé publique \(E\) de chiffrement, qui, comme son nom
l'indique, peut être partagé de manière publique et dont le contenu peut
être connu de tous. Cela résout ainsi le problème de transmission de la
clé, comme identifié en
\emph{\href{Introduction\%20au\%20Chiffrement\%20-\%20Théories\%20et\%20Pratiques\%20du\%20Chiffrement\%20Symétrique\%20et\%20Asymétrique\%20avec\%20une\%20Étude\%20de\%20Cas\%20sur\%20l'Algorithme\%20RSA.\#Def\%205.2.1}{Def
5.2.1}}.

Le fonctionnement et la sécurité de cette méthode repose sur le fait que
bien que \(D\) est déterminé par \(E\), il est impraticable de calculer
\(D\) à partir de \(E\). Ainsi toute personne en possession de \(E\) ne
peut en déduire \(D\) et n'est donc pas en mesure de déchiffrer les
messages chiffrés avec \(E\).\footnote{\href{https://dl.acm.org/doi/pdf/10.1145/1499799.1499815}{Diffie,
  W., \& Hellman, M. E. (1976). Multiuser cryptographic techniques. In
  \emph{Proceedings of the June 7-10, 1976, national computer conference
  and exposition} (pp.~109--112). essay, Association for Computing
  Machinery.} (En Anglais.)}

Une mise en pratique concrète de cette méthode ressemblerai à ceci :

\begin{itemize}
\tightlist
\item
  Alice veut pouvoir recevoir des messages de la part de Bob de manière
  sécurisée.
\item
  Alice génère deux clés, une clé privée \(D\), qu'elle garde pour elle,
  et une clé publique \(E\), qu'elle envoie à Bob.
\item
  Bob envoit un message \(M\) à Alice qu'il chiffre avec la clé publique
  \(E\).
\item
  Alice reçoit le message chiffré \(C\) puis le déchiffre avec la clé
  privée \(D\) et obtient le message \(M\).
\item
  Marie, qui espionnait la conversation depuis tout ce temps, a réussi à
  intercepter le message chiffré \(C\) qu'a envoyé Bob et la clé
  publique \(E\) qu'il a utilisé pour le chiffrer.
\item
  Malgré toutes ses tentatives, Marie n'arrive pas à déchiffrer le
  message \(C\) de Bob.
\end{itemize}

Vient enfin le moment de poser l'interrogation qui est le cœur du
raisonnement de cet article et qui est responsable de son existence :

\textbf{Pour un sujet \(A\) en possession d'une clé de chiffrement
publique \(E\) et d'un message \(C\) chiffré par \(E\), pourquoi \(A\)
n'est pas en capacité de déchiffrer \(C\) ?}

Pour aborder cette problématique, nous utiliserons l'algorithme de
chiffrement asymétrique Rivest-Shamir-Adleman (RSA) comme objet d'étude.
Nous nous concentrerons spécifiquement sur les principes mathématiques
régissant la génération de la paire de clés.

Après tout c'est vrai que dans les mathématiques que l'on a apprises à
l'école, nous avons toujours plus ou moins inconsciemment compris qu'une
fonction mathématique possédait toujours son inverse : on peut inverser
une addition avec une soustraction, même chose pour la multiplication
qui s'inverse avec une division.

Et, de manière plus générale, dans une équation à 3 valeurs, comme une
addition, que l'on peut noter ainsi : \[
x + y = z
\] Il nous est possible de retrouver l'inconnue à partir du moment où
l'on connaît les deux autres valeurs.

\textbf{Ex (courant) :} \[
1+2=?
\] Dans cet exemple, plus que courant, il suffit d'additionner les deux
valeurs pour trouver l'inconnue, qui est notre troisième valeur.

\textbf{Ex (moins courant) :} \[
1+?=3
\] Dans cet exemple, légèrement moins courant, on peut tout de même
trouver l'inconnue, il suffit de soustraire \(1\) à \(3\) et l'on
obtient \(2\), notre inconnue est donc égale à \(2\).

\textbf{Marie se trouve dans cette situation :} \[
M+c=C
\] Ici, \(c\) représente la clé de chiffrement, \(C\) le message chiffré
et \(M\) le message en clair.

Marie possède donc bien deux valeurs sur trois : \(c\) et \(C\),
respectivement la clé de chiffrement et le message chiffré. Pourtant, il
n'est pas possible de déchiffrer le message, même avec ces deux
éléments.

Plongeons-nous alors un petit peu dans le monde des mathématiques pour
expliquer le pourquoi du comment.

\begin{quote}
Info : À noter que je vais détailler ici la génération de clés pour le
protocole RSA, qui est le protocole de chiffrement asymétrique le plus
connu et le plus utilisé, cependant retenez bien qu'il ne s'agit pas de
l'unique protocole de chiffrement asymétrique.
\end{quote}

Pour commencer il nous faut deux valeurs \(p\) et \(q\), qui doivent
respectivement être des nombres premiers, pour ceux qui auraient oublié,
les nombres premiers ont cette particularité de ne se diviser que par
\(1\) et eux-mêmes, par exemple le chiffre \(7\) n'est divisible que par
\(7\), donc lui-même, et par \(1\).

Ensuite, il nous faut trouver la valeur \(n\), qui est égal à \(p\)
multiplié par \(q\). Faisons un exemple : définissons \(p\) par \(11\)
et \(q\) par \(13\). Si on multiplie donc ces deux valeurs, on obtient
\(143\).

Ensuite, il nous faut trouver une variante de \(n\), à savoir
\(\phi(n)\), qui est égal à \((p-1)\times(q-1)\), donc dans notre
exemple : \[(11-1)\times(13-1)=10\times12=120\]

Ça va nous permettre de trouver \(e\), qui est égal à un nombre premier
quelconque à condition qu'il soit différent de \(\phi(n)\), on peut le
noter ainsi : \[
e \in \mathbb{P}\ne \phi(n)
\] Pour notre exemple, \(7\) fonctionne bien.

Enfin, il nous manque \(d\), qui va nous permettre de générer notre clé
privée, qui est égal à l'inverse modulaire de \(e \bmod \phi(n\)), que
l'on peut noter \[d \times e \equiv 1 (\bmod \phi(n))\]

Je vous vois venir, Modulo c'est un dérivé de la division euclidienne,
qui a la particularité de ne travailler qu'avec des entiers, ce qui a
pour conséquence de nous donner un reste. Par exemple si on divise
\(45\) par \(12\), on obtient un quotient de \(3\) et un reste de \(9\).
Eh bien modulo, c'est le calcul de ce reste, en termes plus concret,
c'est le calcul du reste d'une division euclidienne.

Pour finir, il nous manque notre valeur \(M\), qui est égal au message
qu'on souhaite chiffrer, par exemple, ``Hello world''. Problème, on ne
sait pas encore calculer des lettres, il faut donc convertir ces lettres
en nombres, on peut par exemple utiliser la table ASCII pour convertir
``H'' en \(104\).

Voilà maintenant, on a toutes nos valeurs pour générer notre clé
publique via la formule suivante : \[
C = M^e \bmod n
\] où \(C\) représente notre message une fois chiffré.

Et notre clé privée : \[
M = C^d \bmod n
\]

En utilisant notre exemple, cela donne, pour notre clé publique, la
formule suivante : \[
104^{7} \bmod 143
\] Ce qui donne pour résultat \(91\).

Bravo, vous venez de chiffrer un message !

\section{7. Le protocole RSA, incassable
?}\label{le-protocole-rsa-incassable}

Alors comment se fait-il que l'on ne puisse pas récupérer le message en
clair en étant en possession de la clé publique ? Ne peut-on pas
simplement inverser la fonction de chiffrement ?

Eh bien\ldots{} Non, parce que la fonction \(\text{modulo}\) est une
fonction que l'on appelle ``à sens unique'', il n'est pas possible de
l'inverser. L'unique moyen de trouver la valeur originale d'une fonction
\(\text{modulo}\) à partir de son résultat, c'est de tester toutes les
valeurs comprises entre \(0\) et \(\infty\) en entrée jusqu'à ce qu'on
obtienne \(C\). Et, entre nous, c'est long, fastidieux et chiant.

Surtout quand on sait qu'il existe une solution plus simple et rapide :
générer la clé privée à partir de la clé publique. Mais comment fait-on
? Eh bien il nous faut trouver \(p\) et \(q\) afin de pouvoir calculer
\(\phi(n)\) nécessaire à la génération de \(d\) (\emph{qui est la
composante principale de la clé privée}). Et on a de la chance, on sait
que lors de la génération d'une clé RSA, \(p\) et \(q\) doivent
obligatoirement être des nombres premiers, donc pour arriver à nos fins,
il nous suffit de factoriser \(n\). Ce qui consiste à tester la
divisibilité de \(n\) avec tous les nombres premiers, jusqu'à ce que
l'on obtienne un entier comme résultat.

Testons avec notre précédent exemple, où \(n = 143\), on va donc tenter
de le diviser par chaque nombre premier :

\begin{itemize}
\tightlist
\item
  Avec \(2\) on obtient \(71.5\) (\(143 \div 2\)), ce qui n'est pas bon,
  vu qu'on obtient un résultat avec décimales (\emph{donc pas un
  entier}).
\item
  Avec \(3\) on obtient \(47.667\) (\(143\div3\)), ce qui est également
  incorrect à cause de la décimale.
\item
  Avec \(5\) on obtient \(28.6\) (\(143\div5\)), ce qui est incorrect.
\item
  Avec \(7\) on obtient \(20.428\) (\(143\div7\)), ce qui est incorrect.
\item
  Avec \(11\) on obtient \(13\) (\(143\div11\)), ce qui est correct, on
  trouve bien un entier (\emph{donc sans décimales}) ce qui signifie que
  \(143\) est divisible par \(11\) et que donc \(p = 11\).
\end{itemize}

Cela nous permet de faire d'une pierre deux coups, puisqu'en divisant
\(143\) par \(11\), on obtient \(q\), donc ici \(q = 13\), on sait donc
que \(p = 11\) et \(q = 13\).

Il ne nous reste donc plus qu'à calculer \(\phi(n)\) pour trouver \(d\),
et on peut générer la clé privée, puis déchiffrer le message.

\section{8. Non, je ne suis pas un
génie.}\label{non-je-ne-suis-pas-un-guxe9nie.}

Et alors autant vous le dire tout de suite, non, je ne suis pas un génie
de la cryptographie et non, je ne viens pas de casser l'un des
protocoles de sécurité les plus utilisés au monde.

En fait, il y a un petit détail que j'ai oublié de vous préciser : la
taille des nombres premiers choisis pour \(p\) et \(q\). Pour rendre
l'explication plus facile, j'ai volontairement choisi de petits nombres,
en réalité, on utilise de bien plus grands nombres, par exemple : \[
5.49 \times 10^{999}
\] \emph{oui, c'est pas mal grand.}

Et rappelez-vous, pour pouvoir retrouver \(p\) et \(q\) à partir de
\(n\), il nous faut diviser \(n\) par tous les nombres premiers jusqu'à
obtenir un entier comme résultat, hors le temps nécessaire pour arriver
à diviser \(n\) par de tels nombres, même pour un superordinateur, se
compte en millions d'années.

Ce qui fait donc du protocole RSA un algorithme de chiffrement
particulier, parce que théoriquement faillible, mais pas en pratique, de
par la durée nécessaire pour factoriser \(n\).

\section{9. RSA, infaillible à tout jamais
?}\label{rsa-infaillible-uxe0-tout-jamais}

Est-ce pour autant que nous ne parviendrons jamais à casser une clé RSA
?

Il y a deux situations plausibles : - La première, c'est que nos
ordinateurs soient devenus suffisamment puissants pour pouvoir réussir à
factoriser \(n\) dans des temps concevables pour l'être humain. Mais,
soyons honnête, il y a peu de chances que cette situation voit le jour.
Déjà parce que cela nécessiterait de faire un bond technologique
gigantesque pour atteindre de telles puissances de calculs, ensuite,
c'est facilement contournable, il suffit d'encore augmenter la taille
des nombres premiers \(p\) et \(q\) pour croître de façon exponentielle
le temps nécessaire pour factoriser \(n\). - La deuxième, c'est
l'algorithme de Shor, dont je réserve l'explication pour un article
futur. Retenez qu'il s'agit d'un algorithme reposant sur la puissance de
l'informatique quantique pour factoriser \(n\) dans des temps
relativement restreint. Jusqu'à ce jour, l'algorithme de Shor n'a été
mis à exécution qu'une fois, en 2001, par IBM, pour factoriser \(15\) en
\(3\) et \(5\), bon autant vous dire que, ça, moi aussi, je sais le
faire. Mais si une expérience de plus grande envergure voit le jour,
elle pourrait alors sérieusement compromettre la sécurité de beaucoup de
protocoles utilisant l'algorithme RSA, comme certains réseaux bancaires.
Mais ne paniquez pas trop vite, l'attaquant doit tout de même être en
possession d'un calculateur quantique pour mettre l'algorithme de Shor à
exécution, et ça ne court pas les rues.

\section{10. Conclusion :}\label{conclusion}

Le protocole RSA à encore de beaux jours devant lui, parce que malgré le
fait qu'il repose sur des principes mathématiques relativement simples,
il offre une sécurité impressionnante grâce à la difficulté pratique de
la factorisation de \(n\). Cette complexité rend RSA théoriquement
vulnérable, mais pratiquement incassable avec les moyens actuels.

Cependant, il est important de noter que la sécurité en cryptographie
n'est jamais absolue. Les avancées technologiques, notamment dans le
domaine de l'informatique quantique, pourraient un jour remettre en
question la solidité de RSA. L'algorithme de Shor, par exemple, démontre
qu'un ordinateur quantique suffisamment puissant pourrait factoriser
\(n\) dans des temps suffisamment restreint pour pouvoir sérieusement
menacer la sécurité des systèmes basés sur RSA.

Néanmoins, la communauté scientifique est consciente de ça et travaille
déjà sur des algorithmes pouvant résister à l'informatique quantique.
Cela porte d'ailleurs un nom : la cryptographie post-quantique.

Je vous encourage à approfondir vos connaissances en cryptographie et à
consulter les sources fiables disponibles ci-dessous pour aller plus
loin.

\end{document}